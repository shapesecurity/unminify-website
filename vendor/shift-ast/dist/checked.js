'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Generated by src/generate-checked.js.

/**
 * Copyright 2016 Shape Security, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License")
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function isNotExpression(node) {
  return node === undefined || node.type !== 'ArrayExpression' && node.type !== 'ArrowExpression' && node.type !== 'AssignmentExpression' && node.type !== 'BinaryExpression' && node.type !== 'CallExpression' && node.type !== 'ClassExpression' && node.type !== 'CompoundAssignmentExpression' && node.type !== 'ConditionalExpression' && node.type !== 'FunctionExpression' && node.type !== 'IdentifierExpression' && node.type !== 'LiteralBooleanExpression' && node.type !== 'LiteralInfinityExpression' && node.type !== 'LiteralNullExpression' && node.type !== 'LiteralNumericExpression' && node.type !== 'LiteralRegExpExpression' && node.type !== 'LiteralStringExpression' && node.type !== 'ComputedMemberExpression' && node.type !== 'StaticMemberExpression' && node.type !== 'NewExpression' && node.type !== 'NewTargetExpression' && node.type !== 'ObjectExpression' && node.type !== 'TemplateExpression' && node.type !== 'ThisExpression' && node.type !== 'UnaryExpression' && node.type !== 'UpdateExpression' && node.type !== 'YieldExpression' && node.type !== 'YieldGeneratorExpression';
}

function isNotStatement(node) {
  return node === undefined || node.type !== 'BlockStatement' && node.type !== 'BreakStatement' && node.type !== 'ClassDeclaration' && node.type !== 'ContinueStatement' && node.type !== 'DebuggerStatement' && node.type !== 'EmptyStatement' && node.type !== 'ExpressionStatement' && node.type !== 'FunctionDeclaration' && node.type !== 'IfStatement' && node.type !== 'DoWhileStatement' && node.type !== 'ForInStatement' && node.type !== 'ForOfStatement' && node.type !== 'ForStatement' && node.type !== 'WhileStatement' && node.type !== 'LabeledStatement' && node.type !== 'ReturnStatement' && node.type !== 'SwitchStatement' && node.type !== 'SwitchStatementWithDefault' && node.type !== 'ThrowStatement' && node.type !== 'TryCatchStatement' && node.type !== 'TryFinallyStatement' && node.type !== 'VariableDeclarationStatement' && node.type !== 'WithStatement';
}

function printActualType(arg) {
  if ((typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) !== 'object') {
    return typeof arg === 'undefined' ? 'undefined' : _typeof(arg);
  }
  if (Array.isArray(arg)) {
    return '[' + arg.map(printActualType).join(', ') + ']';
  }
  if (arg === null) {
    return null;
  }
  if (!arg.type) {
    return JSON.stringify(arg);
  }
  return arg.type;
}

var ArrayAssignmentTarget = exports.ArrayAssignmentTarget = function ArrayAssignmentTarget(_ref) {
  var elements = _ref.elements;
  var rest = _ref.rest;

  _classCallCheck(this, ArrayAssignmentTarget);

  if (elements === undefined || !Array.isArray(elements) || elements.some(function (f) {
    return f === undefined || f !== null && f.type !== 'AssignmentTargetWithDefault' && f.type !== 'ArrayAssignmentTarget' && f.type !== 'ObjectAssignmentTarget' && f.type !== 'AssignmentTargetIdentifier' && f.type !== 'ComputedMemberAssignmentTarget' && f.type !== 'StaticMemberAssignmentTarget';
  })) {
    throw new TypeError('Field "elements" of ArrayAssignmentTarget constructor is of incorrect type (expected [null or one of {AssignmentTargetWithDefault, ArrayAssignmentTarget, ObjectAssignmentTarget, AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget}], got ' + printActualType(elements) + ')');
  }
  if (rest === undefined || rest !== null && rest.type !== 'ArrayAssignmentTarget' && rest.type !== 'ObjectAssignmentTarget' && rest.type !== 'AssignmentTargetIdentifier' && rest.type !== 'ComputedMemberAssignmentTarget' && rest.type !== 'StaticMemberAssignmentTarget') {
    throw new TypeError('Field "rest" of ArrayAssignmentTarget constructor is of incorrect type (expected null or one of {ArrayAssignmentTarget, ObjectAssignmentTarget, AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget}, got ' + printActualType(rest) + ')');
  }
  this.type = 'ArrayAssignmentTarget';
  this.elements = elements;
  this.rest = rest;
};

var ArrayBinding = exports.ArrayBinding = function ArrayBinding(_ref2) {
  var elements = _ref2.elements;
  var rest = _ref2.rest;

  _classCallCheck(this, ArrayBinding);

  if (elements === undefined || !Array.isArray(elements) || elements.some(function (f) {
    return f === undefined || f !== null && f.type !== 'BindingWithDefault' && f.type !== 'BindingIdentifier' && f.type !== 'ArrayBinding' && f.type !== 'ObjectBinding';
  })) {
    throw new TypeError('Field "elements" of ArrayBinding constructor is of incorrect type (expected [null or one of {BindingWithDefault, BindingIdentifier, ArrayBinding, ObjectBinding}], got ' + printActualType(elements) + ')');
  }
  if (rest === undefined || rest !== null && rest.type !== 'BindingIdentifier' && rest.type !== 'ArrayBinding' && rest.type !== 'ObjectBinding') {
    throw new TypeError('Field "rest" of ArrayBinding constructor is of incorrect type (expected null or one of {BindingIdentifier, ArrayBinding, ObjectBinding}, got ' + printActualType(rest) + ')');
  }
  this.type = 'ArrayBinding';
  this.elements = elements;
  this.rest = rest;
};

var ArrayExpression = exports.ArrayExpression = function ArrayExpression(_ref3) {
  var elements = _ref3.elements;

  _classCallCheck(this, ArrayExpression);

  if (elements === undefined || !Array.isArray(elements) || elements.some(function (f) {
    return f === undefined || f !== null && isNotExpression(f) && f.type !== 'SpreadElement';
  })) {
    throw new TypeError('Field "elements" of ArrayExpression constructor is of incorrect type (expected [null or one of {Expression, SpreadElement}], got ' + printActualType(elements) + ')');
  }
  this.type = 'ArrayExpression';
  this.elements = elements;
};

var ArrowExpression = exports.ArrowExpression = function ArrowExpression(_ref4) {
  var params = _ref4.params;
  var body = _ref4.body;

  _classCallCheck(this, ArrowExpression);

  if (params === undefined || params.type !== 'FormalParameters') {
    throw new TypeError('Field "params" of ArrowExpression constructor is of incorrect type (expected FormalParameters, got ' + printActualType(params) + ')');
  }
  if (body === undefined || isNotExpression(body) && body.type !== 'FunctionBody') {
    throw new TypeError('Field "body" of ArrowExpression constructor is of incorrect type (expected one of {Expression, FunctionBody}, got ' + printActualType(body) + ')');
  }
  this.type = 'ArrowExpression';
  this.params = params;
  this.body = body;
};

var AssignmentExpression = exports.AssignmentExpression = function AssignmentExpression(_ref5) {
  var binding = _ref5.binding;
  var expression = _ref5.expression;

  _classCallCheck(this, AssignmentExpression);

  if (binding === undefined || binding.type !== 'ArrayAssignmentTarget' && binding.type !== 'ObjectAssignmentTarget' && binding.type !== 'AssignmentTargetIdentifier' && binding.type !== 'ComputedMemberAssignmentTarget' && binding.type !== 'StaticMemberAssignmentTarget') {
    throw new TypeError('Field "binding" of AssignmentExpression constructor is of incorrect type (expected one of {ArrayAssignmentTarget, ObjectAssignmentTarget, AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget}, got ' + printActualType(binding) + ')');
  }
  if (isNotExpression(expression)) {
    throw new TypeError('Field "expression" of AssignmentExpression constructor is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');
  }
  this.type = 'AssignmentExpression';
  this.binding = binding;
  this.expression = expression;
};

var AssignmentTargetIdentifier = exports.AssignmentTargetIdentifier = function AssignmentTargetIdentifier(_ref6) {
  var name = _ref6.name;

  _classCallCheck(this, AssignmentTargetIdentifier);

  if (name === undefined || typeof name !== 'string') {
    throw new TypeError('Field "name" of AssignmentTargetIdentifier constructor is of incorrect type (expected string, got ' + printActualType(name) + ')');
  }
  this.type = 'AssignmentTargetIdentifier';
  this.name = name;
};

var AssignmentTargetPropertyIdentifier = exports.AssignmentTargetPropertyIdentifier = function AssignmentTargetPropertyIdentifier(_ref7) {
  var binding = _ref7.binding;
  var init = _ref7.init;

  _classCallCheck(this, AssignmentTargetPropertyIdentifier);

  if (binding === undefined || binding.type !== 'AssignmentTargetIdentifier') {
    throw new TypeError('Field "binding" of AssignmentTargetPropertyIdentifier constructor is of incorrect type (expected AssignmentTargetIdentifier, got ' + printActualType(binding) + ')');
  }
  if (init === undefined || init !== null && isNotExpression(init)) {
    throw new TypeError('Field "init" of AssignmentTargetPropertyIdentifier constructor is of incorrect type (expected null or Expression, got ' + printActualType(init) + ')');
  }
  this.type = 'AssignmentTargetPropertyIdentifier';
  this.binding = binding;
  this.init = init;
};

var AssignmentTargetPropertyProperty = exports.AssignmentTargetPropertyProperty = function AssignmentTargetPropertyProperty(_ref8) {
  var name = _ref8.name;
  var binding = _ref8.binding;

  _classCallCheck(this, AssignmentTargetPropertyProperty);

  if (name === undefined || name.type !== 'ComputedPropertyName' && name.type !== 'StaticPropertyName') {
    throw new TypeError('Field "name" of AssignmentTargetPropertyProperty constructor is of incorrect type (expected one of {ComputedPropertyName, StaticPropertyName}, got ' + printActualType(name) + ')');
  }
  if (binding === undefined || binding.type !== 'AssignmentTargetWithDefault' && binding.type !== 'ArrayAssignmentTarget' && binding.type !== 'ObjectAssignmentTarget' && binding.type !== 'AssignmentTargetIdentifier' && binding.type !== 'ComputedMemberAssignmentTarget' && binding.type !== 'StaticMemberAssignmentTarget') {
    throw new TypeError('Field "binding" of AssignmentTargetPropertyProperty constructor is of incorrect type (expected one of {AssignmentTargetWithDefault, ArrayAssignmentTarget, ObjectAssignmentTarget, AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget}, got ' + printActualType(binding) + ')');
  }
  this.type = 'AssignmentTargetPropertyProperty';
  this.name = name;
  this.binding = binding;
};

var AssignmentTargetWithDefault = exports.AssignmentTargetWithDefault = function AssignmentTargetWithDefault(_ref9) {
  var binding = _ref9.binding;
  var init = _ref9.init;

  _classCallCheck(this, AssignmentTargetWithDefault);

  if (binding === undefined || binding.type !== 'ArrayAssignmentTarget' && binding.type !== 'ObjectAssignmentTarget' && binding.type !== 'AssignmentTargetIdentifier' && binding.type !== 'ComputedMemberAssignmentTarget' && binding.type !== 'StaticMemberAssignmentTarget') {
    throw new TypeError('Field "binding" of AssignmentTargetWithDefault constructor is of incorrect type (expected one of {ArrayAssignmentTarget, ObjectAssignmentTarget, AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget}, got ' + printActualType(binding) + ')');
  }
  if (isNotExpression(init)) {
    throw new TypeError('Field "init" of AssignmentTargetWithDefault constructor is of incorrect type (expected Expression, got ' + printActualType(init) + ')');
  }
  this.type = 'AssignmentTargetWithDefault';
  this.binding = binding;
  this.init = init;
};

var BinaryExpression = exports.BinaryExpression = function BinaryExpression(_ref10) {
  var left = _ref10.left;
  var operator = _ref10.operator;
  var right = _ref10.right;

  _classCallCheck(this, BinaryExpression);

  if (isNotExpression(left)) {
    throw new TypeError('Field "left" of BinaryExpression constructor is of incorrect type (expected Expression, got ' + printActualType(left) + ')');
  }
  if (operator === undefined || ["==", "!=", "===", "!==", "<", "<=", ">", ">=", "in", "instanceof", "<<", ">>", ">>>", "+", "-", "*", "/", "%", "**", ",", "||", "&&", "|", "^", "&"].indexOf(operator) === -1) {
    throw new TypeError('Field "operator" of BinaryExpression constructor is of incorrect type (expected one of {"==", "!=", "===", "!==", "<", "<=", ">", ">=", "in", "instanceof", "<<", ">>", ">>>", "+", "-", "*", "/", "%", "**", ",", "||", "&&", "|", "^", "&"}, got ' + printActualType(operator) + ')');
  }
  if (isNotExpression(right)) {
    throw new TypeError('Field "right" of BinaryExpression constructor is of incorrect type (expected Expression, got ' + printActualType(right) + ')');
  }
  this.type = 'BinaryExpression';
  this.left = left;
  this.operator = operator;
  this.right = right;
};

var BindingIdentifier = exports.BindingIdentifier = function BindingIdentifier(_ref11) {
  var name = _ref11.name;

  _classCallCheck(this, BindingIdentifier);

  if (name === undefined || typeof name !== 'string') {
    throw new TypeError('Field "name" of BindingIdentifier constructor is of incorrect type (expected string, got ' + printActualType(name) + ')');
  }
  this.type = 'BindingIdentifier';
  this.name = name;
};

var BindingPropertyIdentifier = exports.BindingPropertyIdentifier = function BindingPropertyIdentifier(_ref12) {
  var binding = _ref12.binding;
  var init = _ref12.init;

  _classCallCheck(this, BindingPropertyIdentifier);

  if (binding === undefined || binding.type !== 'BindingIdentifier') {
    throw new TypeError('Field "binding" of BindingPropertyIdentifier constructor is of incorrect type (expected BindingIdentifier, got ' + printActualType(binding) + ')');
  }
  if (init === undefined || init !== null && isNotExpression(init)) {
    throw new TypeError('Field "init" of BindingPropertyIdentifier constructor is of incorrect type (expected null or Expression, got ' + printActualType(init) + ')');
  }
  this.type = 'BindingPropertyIdentifier';
  this.binding = binding;
  this.init = init;
};

var BindingPropertyProperty = exports.BindingPropertyProperty = function BindingPropertyProperty(_ref13) {
  var name = _ref13.name;
  var binding = _ref13.binding;

  _classCallCheck(this, BindingPropertyProperty);

  if (name === undefined || name.type !== 'ComputedPropertyName' && name.type !== 'StaticPropertyName') {
    throw new TypeError('Field "name" of BindingPropertyProperty constructor is of incorrect type (expected one of {ComputedPropertyName, StaticPropertyName}, got ' + printActualType(name) + ')');
  }
  if (binding === undefined || binding.type !== 'BindingWithDefault' && binding.type !== 'BindingIdentifier' && binding.type !== 'ArrayBinding' && binding.type !== 'ObjectBinding') {
    throw new TypeError('Field "binding" of BindingPropertyProperty constructor is of incorrect type (expected one of {BindingWithDefault, BindingIdentifier, ArrayBinding, ObjectBinding}, got ' + printActualType(binding) + ')');
  }
  this.type = 'BindingPropertyProperty';
  this.name = name;
  this.binding = binding;
};

var BindingWithDefault = exports.BindingWithDefault = function BindingWithDefault(_ref14) {
  var binding = _ref14.binding;
  var init = _ref14.init;

  _classCallCheck(this, BindingWithDefault);

  if (binding === undefined || binding.type !== 'BindingIdentifier' && binding.type !== 'ArrayBinding' && binding.type !== 'ObjectBinding') {
    throw new TypeError('Field "binding" of BindingWithDefault constructor is of incorrect type (expected one of {BindingIdentifier, ArrayBinding, ObjectBinding}, got ' + printActualType(binding) + ')');
  }
  if (isNotExpression(init)) {
    throw new TypeError('Field "init" of BindingWithDefault constructor is of incorrect type (expected Expression, got ' + printActualType(init) + ')');
  }
  this.type = 'BindingWithDefault';
  this.binding = binding;
  this.init = init;
};

var Block = exports.Block = function Block(_ref15) {
  var statements = _ref15.statements;

  _classCallCheck(this, Block);

  if (statements === undefined || !Array.isArray(statements) || statements.some(function (f) {
    return isNotStatement(f);
  })) {
    throw new TypeError('Field "statements" of Block constructor is of incorrect type (expected [Statement], got ' + printActualType(statements) + ')');
  }
  this.type = 'Block';
  this.statements = statements;
};

var BlockStatement = exports.BlockStatement = function BlockStatement(_ref16) {
  var block = _ref16.block;

  _classCallCheck(this, BlockStatement);

  if (block === undefined || block.type !== 'Block') {
    throw new TypeError('Field "block" of BlockStatement constructor is of incorrect type (expected Block, got ' + printActualType(block) + ')');
  }
  this.type = 'BlockStatement';
  this.block = block;
};

var BreakStatement = exports.BreakStatement = function BreakStatement(_ref17) {
  var label = _ref17.label;

  _classCallCheck(this, BreakStatement);

  if (label === undefined || label !== null && typeof label !== 'string') {
    throw new TypeError('Field "label" of BreakStatement constructor is of incorrect type (expected null or string, got ' + printActualType(label) + ')');
  }
  this.type = 'BreakStatement';
  this.label = label;
};

var CallExpression = exports.CallExpression = function CallExpression(_ref18) {
  var callee = _ref18.callee;
  var _arguments = _ref18.arguments;

  _classCallCheck(this, CallExpression);

  if (callee === undefined || isNotExpression(callee) && callee.type !== 'Super') {
    throw new TypeError('Field "callee" of CallExpression constructor is of incorrect type (expected one of {Expression, Super}, got ' + printActualType(callee) + ')');
  }
  if (_arguments === undefined || !Array.isArray(_arguments) || _arguments.some(function (f) {
    return f === undefined || isNotExpression(f) && f.type !== 'SpreadElement';
  })) {
    throw new TypeError('Field "arguments" of CallExpression constructor is of incorrect type (expected [one of {Expression, SpreadElement}], got ' + printActualType(_arguments) + ')');
  }
  this.type = 'CallExpression';
  this.callee = callee;
  this.arguments = _arguments;
};

var CatchClause = exports.CatchClause = function CatchClause(_ref19) {
  var binding = _ref19.binding;
  var body = _ref19.body;

  _classCallCheck(this, CatchClause);

  if (binding === undefined || binding.type !== 'BindingIdentifier' && binding.type !== 'ArrayBinding' && binding.type !== 'ObjectBinding') {
    throw new TypeError('Field "binding" of CatchClause constructor is of incorrect type (expected one of {BindingIdentifier, ArrayBinding, ObjectBinding}, got ' + printActualType(binding) + ')');
  }
  if (body === undefined || body.type !== 'Block') {
    throw new TypeError('Field "body" of CatchClause constructor is of incorrect type (expected Block, got ' + printActualType(body) + ')');
  }
  this.type = 'CatchClause';
  this.binding = binding;
  this.body = body;
};

var ClassDeclaration = exports.ClassDeclaration = function ClassDeclaration(_ref20) {
  var name = _ref20.name;
  var _super = _ref20.super;
  var elements = _ref20.elements;

  _classCallCheck(this, ClassDeclaration);

  if (name === undefined || name.type !== 'BindingIdentifier') {
    throw new TypeError('Field "name" of ClassDeclaration constructor is of incorrect type (expected BindingIdentifier, got ' + printActualType(name) + ')');
  }
  if (_super === undefined || _super !== null && isNotExpression(_super)) {
    throw new TypeError('Field "super" of ClassDeclaration constructor is of incorrect type (expected null or Expression, got ' + printActualType(_super) + ')');
  }
  if (elements === undefined || !Array.isArray(elements) || elements.some(function (f) {
    return f === undefined || f.type !== 'ClassElement';
  })) {
    throw new TypeError('Field "elements" of ClassDeclaration constructor is of incorrect type (expected [ClassElement], got ' + printActualType(elements) + ')');
  }
  this.type = 'ClassDeclaration';
  this.name = name;
  this.super = _super;
  this.elements = elements;
};

var ClassElement = exports.ClassElement = function ClassElement(_ref21) {
  var isStatic = _ref21.isStatic;
  var method = _ref21.method;

  _classCallCheck(this, ClassElement);

  if (isStatic === undefined || typeof isStatic !== 'boolean') {
    throw new TypeError('Field "isStatic" of ClassElement constructor is of incorrect type (expected boolean, got ' + printActualType(isStatic) + ')');
  }
  if (method === undefined || method.type !== 'Getter' && method.type !== 'Method' && method.type !== 'Setter') {
    throw new TypeError('Field "method" of ClassElement constructor is of incorrect type (expected one of {Getter, Method, Setter}, got ' + printActualType(method) + ')');
  }
  this.type = 'ClassElement';
  this.isStatic = isStatic;
  this.method = method;
};

var ClassExpression = exports.ClassExpression = function ClassExpression(_ref22) {
  var name = _ref22.name;
  var _super = _ref22.super;
  var elements = _ref22.elements;

  _classCallCheck(this, ClassExpression);

  if (name === undefined || name !== null && name.type !== 'BindingIdentifier') {
    throw new TypeError('Field "name" of ClassExpression constructor is of incorrect type (expected null or BindingIdentifier, got ' + printActualType(name) + ')');
  }
  if (_super === undefined || _super !== null && isNotExpression(_super)) {
    throw new TypeError('Field "super" of ClassExpression constructor is of incorrect type (expected null or Expression, got ' + printActualType(_super) + ')');
  }
  if (elements === undefined || !Array.isArray(elements) || elements.some(function (f) {
    return f === undefined || f.type !== 'ClassElement';
  })) {
    throw new TypeError('Field "elements" of ClassExpression constructor is of incorrect type (expected [ClassElement], got ' + printActualType(elements) + ')');
  }
  this.type = 'ClassExpression';
  this.name = name;
  this.super = _super;
  this.elements = elements;
};

var CompoundAssignmentExpression = exports.CompoundAssignmentExpression = function CompoundAssignmentExpression(_ref23) {
  var binding = _ref23.binding;
  var operator = _ref23.operator;
  var expression = _ref23.expression;

  _classCallCheck(this, CompoundAssignmentExpression);

  if (binding === undefined || binding.type !== 'AssignmentTargetIdentifier' && binding.type !== 'ComputedMemberAssignmentTarget' && binding.type !== 'StaticMemberAssignmentTarget') {
    throw new TypeError('Field "binding" of CompoundAssignmentExpression constructor is of incorrect type (expected one of {AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget}, got ' + printActualType(binding) + ')');
  }
  if (operator === undefined || ["+=", "-=", "*=", "/=", "%=", "**=", "<<=", ">>=", ">>>=", "|=", "^=", "&="].indexOf(operator) === -1) {
    throw new TypeError('Field "operator" of CompoundAssignmentExpression constructor is of incorrect type (expected one of {"+=", "-=", "*=", "/=", "%=", "**=", "<<=", ">>=", ">>>=", "|=", "^=", "&="}, got ' + printActualType(operator) + ')');
  }
  if (isNotExpression(expression)) {
    throw new TypeError('Field "expression" of CompoundAssignmentExpression constructor is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');
  }
  this.type = 'CompoundAssignmentExpression';
  this.binding = binding;
  this.operator = operator;
  this.expression = expression;
};

var ComputedMemberAssignmentTarget = exports.ComputedMemberAssignmentTarget = function ComputedMemberAssignmentTarget(_ref24) {
  var object = _ref24.object;
  var expression = _ref24.expression;

  _classCallCheck(this, ComputedMemberAssignmentTarget);

  if (object === undefined || isNotExpression(object) && object.type !== 'Super') {
    throw new TypeError('Field "object" of ComputedMemberAssignmentTarget constructor is of incorrect type (expected one of {Expression, Super}, got ' + printActualType(object) + ')');
  }
  if (isNotExpression(expression)) {
    throw new TypeError('Field "expression" of ComputedMemberAssignmentTarget constructor is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');
  }
  this.type = 'ComputedMemberAssignmentTarget';
  this.object = object;
  this.expression = expression;
};

var ComputedMemberExpression = exports.ComputedMemberExpression = function ComputedMemberExpression(_ref25) {
  var object = _ref25.object;
  var expression = _ref25.expression;

  _classCallCheck(this, ComputedMemberExpression);

  if (object === undefined || isNotExpression(object) && object.type !== 'Super') {
    throw new TypeError('Field "object" of ComputedMemberExpression constructor is of incorrect type (expected one of {Expression, Super}, got ' + printActualType(object) + ')');
  }
  if (isNotExpression(expression)) {
    throw new TypeError('Field "expression" of ComputedMemberExpression constructor is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');
  }
  this.type = 'ComputedMemberExpression';
  this.object = object;
  this.expression = expression;
};

var ComputedPropertyName = exports.ComputedPropertyName = function ComputedPropertyName(_ref26) {
  var expression = _ref26.expression;

  _classCallCheck(this, ComputedPropertyName);

  if (isNotExpression(expression)) {
    throw new TypeError('Field "expression" of ComputedPropertyName constructor is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');
  }
  this.type = 'ComputedPropertyName';
  this.expression = expression;
};

var ConditionalExpression = exports.ConditionalExpression = function ConditionalExpression(_ref27) {
  var test = _ref27.test;
  var consequent = _ref27.consequent;
  var alternate = _ref27.alternate;

  _classCallCheck(this, ConditionalExpression);

  if (isNotExpression(test)) {
    throw new TypeError('Field "test" of ConditionalExpression constructor is of incorrect type (expected Expression, got ' + printActualType(test) + ')');
  }
  if (isNotExpression(consequent)) {
    throw new TypeError('Field "consequent" of ConditionalExpression constructor is of incorrect type (expected Expression, got ' + printActualType(consequent) + ')');
  }
  if (isNotExpression(alternate)) {
    throw new TypeError('Field "alternate" of ConditionalExpression constructor is of incorrect type (expected Expression, got ' + printActualType(alternate) + ')');
  }
  this.type = 'ConditionalExpression';
  this.test = test;
  this.consequent = consequent;
  this.alternate = alternate;
};

var ContinueStatement = exports.ContinueStatement = function ContinueStatement(_ref28) {
  var label = _ref28.label;

  _classCallCheck(this, ContinueStatement);

  if (label === undefined || label !== null && typeof label !== 'string') {
    throw new TypeError('Field "label" of ContinueStatement constructor is of incorrect type (expected null or string, got ' + printActualType(label) + ')');
  }
  this.type = 'ContinueStatement';
  this.label = label;
};

var DataProperty = exports.DataProperty = function DataProperty(_ref29) {
  var name = _ref29.name;
  var expression = _ref29.expression;

  _classCallCheck(this, DataProperty);

  if (name === undefined || name.type !== 'ComputedPropertyName' && name.type !== 'StaticPropertyName') {
    throw new TypeError('Field "name" of DataProperty constructor is of incorrect type (expected one of {ComputedPropertyName, StaticPropertyName}, got ' + printActualType(name) + ')');
  }
  if (isNotExpression(expression)) {
    throw new TypeError('Field "expression" of DataProperty constructor is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');
  }
  this.type = 'DataProperty';
  this.name = name;
  this.expression = expression;
};

var DebuggerStatement = exports.DebuggerStatement = function DebuggerStatement() {
  _classCallCheck(this, DebuggerStatement);

  this.type = 'DebuggerStatement';
};

var Directive = exports.Directive = function Directive(_ref30) {
  var rawValue = _ref30.rawValue;

  _classCallCheck(this, Directive);

  if (rawValue === undefined || typeof rawValue !== 'string') {
    throw new TypeError('Field "rawValue" of Directive constructor is of incorrect type (expected string, got ' + printActualType(rawValue) + ')');
  }
  this.type = 'Directive';
  this.rawValue = rawValue;
};

var DoWhileStatement = exports.DoWhileStatement = function DoWhileStatement(_ref31) {
  var body = _ref31.body;
  var test = _ref31.test;

  _classCallCheck(this, DoWhileStatement);

  if (isNotStatement(body)) {
    throw new TypeError('Field "body" of DoWhileStatement constructor is of incorrect type (expected Statement, got ' + printActualType(body) + ')');
  }
  if (isNotExpression(test)) {
    throw new TypeError('Field "test" of DoWhileStatement constructor is of incorrect type (expected Expression, got ' + printActualType(test) + ')');
  }
  this.type = 'DoWhileStatement';
  this.body = body;
  this.test = test;
};

var EmptyStatement = exports.EmptyStatement = function EmptyStatement() {
  _classCallCheck(this, EmptyStatement);

  this.type = 'EmptyStatement';
};

var Export = exports.Export = function Export(_ref32) {
  var declaration = _ref32.declaration;

  _classCallCheck(this, Export);

  if (declaration === undefined || declaration.type !== 'ClassDeclaration' && declaration.type !== 'FunctionDeclaration' && declaration.type !== 'VariableDeclaration') {
    throw new TypeError('Field "declaration" of Export constructor is of incorrect type (expected one of {ClassDeclaration, FunctionDeclaration, VariableDeclaration}, got ' + printActualType(declaration) + ')');
  }
  this.type = 'Export';
  this.declaration = declaration;
};

var ExportAllFrom = exports.ExportAllFrom = function ExportAllFrom(_ref33) {
  var moduleSpecifier = _ref33.moduleSpecifier;

  _classCallCheck(this, ExportAllFrom);

  if (moduleSpecifier === undefined || typeof moduleSpecifier !== 'string') {
    throw new TypeError('Field "moduleSpecifier" of ExportAllFrom constructor is of incorrect type (expected string, got ' + printActualType(moduleSpecifier) + ')');
  }
  this.type = 'ExportAllFrom';
  this.moduleSpecifier = moduleSpecifier;
};

var ExportDefault = exports.ExportDefault = function ExportDefault(_ref34) {
  var body = _ref34.body;

  _classCallCheck(this, ExportDefault);

  if (body === undefined || body.type !== 'ClassDeclaration' && isNotExpression(body) && body.type !== 'FunctionDeclaration') {
    throw new TypeError('Field "body" of ExportDefault constructor is of incorrect type (expected one of {ClassDeclaration, Expression, FunctionDeclaration}, got ' + printActualType(body) + ')');
  }
  this.type = 'ExportDefault';
  this.body = body;
};

var ExportFrom = exports.ExportFrom = function ExportFrom(_ref35) {
  var namedExports = _ref35.namedExports;
  var moduleSpecifier = _ref35.moduleSpecifier;

  _classCallCheck(this, ExportFrom);

  if (namedExports === undefined || !Array.isArray(namedExports) || namedExports.some(function (f) {
    return f === undefined || f.type !== 'ExportFromSpecifier';
  })) {
    throw new TypeError('Field "namedExports" of ExportFrom constructor is of incorrect type (expected [ExportFromSpecifier], got ' + printActualType(namedExports) + ')');
  }
  if (moduleSpecifier === undefined || typeof moduleSpecifier !== 'string') {
    throw new TypeError('Field "moduleSpecifier" of ExportFrom constructor is of incorrect type (expected string, got ' + printActualType(moduleSpecifier) + ')');
  }
  this.type = 'ExportFrom';
  this.namedExports = namedExports;
  this.moduleSpecifier = moduleSpecifier;
};

var ExportFromSpecifier = exports.ExportFromSpecifier = function ExportFromSpecifier(_ref36) {
  var name = _ref36.name;
  var exportedName = _ref36.exportedName;

  _classCallCheck(this, ExportFromSpecifier);

  if (name === undefined || typeof name !== 'string') {
    throw new TypeError('Field "name" of ExportFromSpecifier constructor is of incorrect type (expected string, got ' + printActualType(name) + ')');
  }
  if (exportedName === undefined || exportedName !== null && typeof exportedName !== 'string') {
    throw new TypeError('Field "exportedName" of ExportFromSpecifier constructor is of incorrect type (expected null or string, got ' + printActualType(exportedName) + ')');
  }
  this.type = 'ExportFromSpecifier';
  this.name = name;
  this.exportedName = exportedName;
};

var ExportLocalSpecifier = exports.ExportLocalSpecifier = function ExportLocalSpecifier(_ref37) {
  var name = _ref37.name;
  var exportedName = _ref37.exportedName;

  _classCallCheck(this, ExportLocalSpecifier);

  if (name === undefined || name.type !== 'IdentifierExpression') {
    throw new TypeError('Field "name" of ExportLocalSpecifier constructor is of incorrect type (expected IdentifierExpression, got ' + printActualType(name) + ')');
  }
  if (exportedName === undefined || exportedName !== null && typeof exportedName !== 'string') {
    throw new TypeError('Field "exportedName" of ExportLocalSpecifier constructor is of incorrect type (expected null or string, got ' + printActualType(exportedName) + ')');
  }
  this.type = 'ExportLocalSpecifier';
  this.name = name;
  this.exportedName = exportedName;
};

var ExportLocals = exports.ExportLocals = function ExportLocals(_ref38) {
  var namedExports = _ref38.namedExports;

  _classCallCheck(this, ExportLocals);

  if (namedExports === undefined || !Array.isArray(namedExports) || namedExports.some(function (f) {
    return f === undefined || f.type !== 'ExportLocalSpecifier';
  })) {
    throw new TypeError('Field "namedExports" of ExportLocals constructor is of incorrect type (expected [ExportLocalSpecifier], got ' + printActualType(namedExports) + ')');
  }
  this.type = 'ExportLocals';
  this.namedExports = namedExports;
};

var ExpressionStatement = exports.ExpressionStatement = function ExpressionStatement(_ref39) {
  var expression = _ref39.expression;

  _classCallCheck(this, ExpressionStatement);

  if (isNotExpression(expression)) {
    throw new TypeError('Field "expression" of ExpressionStatement constructor is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');
  }
  this.type = 'ExpressionStatement';
  this.expression = expression;
};

var ForInStatement = exports.ForInStatement = function ForInStatement(_ref40) {
  var left = _ref40.left;
  var right = _ref40.right;
  var body = _ref40.body;

  _classCallCheck(this, ForInStatement);

  if (left === undefined || left.type !== 'ArrayAssignmentTarget' && left.type !== 'ObjectAssignmentTarget' && left.type !== 'AssignmentTargetIdentifier' && left.type !== 'ComputedMemberAssignmentTarget' && left.type !== 'StaticMemberAssignmentTarget' && left.type !== 'VariableDeclaration') {
    throw new TypeError('Field "left" of ForInStatement constructor is of incorrect type (expected one of {ArrayAssignmentTarget, ObjectAssignmentTarget, AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget, VariableDeclaration}, got ' + printActualType(left) + ')');
  }
  if (isNotExpression(right)) {
    throw new TypeError('Field "right" of ForInStatement constructor is of incorrect type (expected Expression, got ' + printActualType(right) + ')');
  }
  if (isNotStatement(body)) {
    throw new TypeError('Field "body" of ForInStatement constructor is of incorrect type (expected Statement, got ' + printActualType(body) + ')');
  }
  this.type = 'ForInStatement';
  this.left = left;
  this.right = right;
  this.body = body;
};

var ForOfStatement = exports.ForOfStatement = function ForOfStatement(_ref41) {
  var left = _ref41.left;
  var right = _ref41.right;
  var body = _ref41.body;

  _classCallCheck(this, ForOfStatement);

  if (left === undefined || left.type !== 'ArrayAssignmentTarget' && left.type !== 'ObjectAssignmentTarget' && left.type !== 'AssignmentTargetIdentifier' && left.type !== 'ComputedMemberAssignmentTarget' && left.type !== 'StaticMemberAssignmentTarget' && left.type !== 'VariableDeclaration') {
    throw new TypeError('Field "left" of ForOfStatement constructor is of incorrect type (expected one of {ArrayAssignmentTarget, ObjectAssignmentTarget, AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget, VariableDeclaration}, got ' + printActualType(left) + ')');
  }
  if (isNotExpression(right)) {
    throw new TypeError('Field "right" of ForOfStatement constructor is of incorrect type (expected Expression, got ' + printActualType(right) + ')');
  }
  if (isNotStatement(body)) {
    throw new TypeError('Field "body" of ForOfStatement constructor is of incorrect type (expected Statement, got ' + printActualType(body) + ')');
  }
  this.type = 'ForOfStatement';
  this.left = left;
  this.right = right;
  this.body = body;
};

var ForStatement = exports.ForStatement = function ForStatement(_ref42) {
  var init = _ref42.init;
  var test = _ref42.test;
  var update = _ref42.update;
  var body = _ref42.body;

  _classCallCheck(this, ForStatement);

  if (init === undefined || init !== null && isNotExpression(init) && init.type !== 'VariableDeclaration') {
    throw new TypeError('Field "init" of ForStatement constructor is of incorrect type (expected null or one of {Expression, VariableDeclaration}, got ' + printActualType(init) + ')');
  }
  if (test === undefined || test !== null && isNotExpression(test)) {
    throw new TypeError('Field "test" of ForStatement constructor is of incorrect type (expected null or Expression, got ' + printActualType(test) + ')');
  }
  if (update === undefined || update !== null && isNotExpression(update)) {
    throw new TypeError('Field "update" of ForStatement constructor is of incorrect type (expected null or Expression, got ' + printActualType(update) + ')');
  }
  if (isNotStatement(body)) {
    throw new TypeError('Field "body" of ForStatement constructor is of incorrect type (expected Statement, got ' + printActualType(body) + ')');
  }
  this.type = 'ForStatement';
  this.init = init;
  this.test = test;
  this.update = update;
  this.body = body;
};

var FormalParameters = exports.FormalParameters = function FormalParameters(_ref43) {
  var items = _ref43.items;
  var rest = _ref43.rest;

  _classCallCheck(this, FormalParameters);

  if (items === undefined || !Array.isArray(items) || items.some(function (f) {
    return f === undefined || f.type !== 'BindingWithDefault' && f.type !== 'BindingIdentifier' && f.type !== 'ArrayBinding' && f.type !== 'ObjectBinding';
  })) {
    throw new TypeError('Field "items" of FormalParameters constructor is of incorrect type (expected [one of {BindingWithDefault, BindingIdentifier, ArrayBinding, ObjectBinding}], got ' + printActualType(items) + ')');
  }
  if (rest === undefined || rest !== null && rest.type !== 'BindingIdentifier' && rest.type !== 'ArrayBinding' && rest.type !== 'ObjectBinding') {
    throw new TypeError('Field "rest" of FormalParameters constructor is of incorrect type (expected null or one of {BindingIdentifier, ArrayBinding, ObjectBinding}, got ' + printActualType(rest) + ')');
  }
  this.type = 'FormalParameters';
  this.items = items;
  this.rest = rest;
};

var FunctionBody = exports.FunctionBody = function FunctionBody(_ref44) {
  var directives = _ref44.directives;
  var statements = _ref44.statements;

  _classCallCheck(this, FunctionBody);

  if (directives === undefined || !Array.isArray(directives) || directives.some(function (f) {
    return f === undefined || f.type !== 'Directive';
  })) {
    throw new TypeError('Field "directives" of FunctionBody constructor is of incorrect type (expected [Directive], got ' + printActualType(directives) + ')');
  }
  if (statements === undefined || !Array.isArray(statements) || statements.some(function (f) {
    return isNotStatement(f);
  })) {
    throw new TypeError('Field "statements" of FunctionBody constructor is of incorrect type (expected [Statement], got ' + printActualType(statements) + ')');
  }
  this.type = 'FunctionBody';
  this.directives = directives;
  this.statements = statements;
};

var FunctionDeclaration = exports.FunctionDeclaration = function FunctionDeclaration(_ref45) {
  var isGenerator = _ref45.isGenerator;
  var name = _ref45.name;
  var params = _ref45.params;
  var body = _ref45.body;

  _classCallCheck(this, FunctionDeclaration);

  if (isGenerator === undefined || typeof isGenerator !== 'boolean') {
    throw new TypeError('Field "isGenerator" of FunctionDeclaration constructor is of incorrect type (expected boolean, got ' + printActualType(isGenerator) + ')');
  }
  if (name === undefined || name.type !== 'BindingIdentifier') {
    throw new TypeError('Field "name" of FunctionDeclaration constructor is of incorrect type (expected BindingIdentifier, got ' + printActualType(name) + ')');
  }
  if (params === undefined || params.type !== 'FormalParameters') {
    throw new TypeError('Field "params" of FunctionDeclaration constructor is of incorrect type (expected FormalParameters, got ' + printActualType(params) + ')');
  }
  if (body === undefined || body.type !== 'FunctionBody') {
    throw new TypeError('Field "body" of FunctionDeclaration constructor is of incorrect type (expected FunctionBody, got ' + printActualType(body) + ')');
  }
  this.type = 'FunctionDeclaration';
  this.isGenerator = isGenerator;
  this.name = name;
  this.params = params;
  this.body = body;
};

var FunctionExpression = exports.FunctionExpression = function FunctionExpression(_ref46) {
  var isGenerator = _ref46.isGenerator;
  var name = _ref46.name;
  var params = _ref46.params;
  var body = _ref46.body;

  _classCallCheck(this, FunctionExpression);

  if (isGenerator === undefined || typeof isGenerator !== 'boolean') {
    throw new TypeError('Field "isGenerator" of FunctionExpression constructor is of incorrect type (expected boolean, got ' + printActualType(isGenerator) + ')');
  }
  if (name === undefined || name !== null && name.type !== 'BindingIdentifier') {
    throw new TypeError('Field "name" of FunctionExpression constructor is of incorrect type (expected null or BindingIdentifier, got ' + printActualType(name) + ')');
  }
  if (params === undefined || params.type !== 'FormalParameters') {
    throw new TypeError('Field "params" of FunctionExpression constructor is of incorrect type (expected FormalParameters, got ' + printActualType(params) + ')');
  }
  if (body === undefined || body.type !== 'FunctionBody') {
    throw new TypeError('Field "body" of FunctionExpression constructor is of incorrect type (expected FunctionBody, got ' + printActualType(body) + ')');
  }
  this.type = 'FunctionExpression';
  this.isGenerator = isGenerator;
  this.name = name;
  this.params = params;
  this.body = body;
};

var Getter = exports.Getter = function Getter(_ref47) {
  var name = _ref47.name;
  var body = _ref47.body;

  _classCallCheck(this, Getter);

  if (name === undefined || name.type !== 'ComputedPropertyName' && name.type !== 'StaticPropertyName') {
    throw new TypeError('Field "name" of Getter constructor is of incorrect type (expected one of {ComputedPropertyName, StaticPropertyName}, got ' + printActualType(name) + ')');
  }
  if (body === undefined || body.type !== 'FunctionBody') {
    throw new TypeError('Field "body" of Getter constructor is of incorrect type (expected FunctionBody, got ' + printActualType(body) + ')');
  }
  this.type = 'Getter';
  this.name = name;
  this.body = body;
};

var IdentifierExpression = exports.IdentifierExpression = function IdentifierExpression(_ref48) {
  var name = _ref48.name;

  _classCallCheck(this, IdentifierExpression);

  if (name === undefined || typeof name !== 'string') {
    throw new TypeError('Field "name" of IdentifierExpression constructor is of incorrect type (expected string, got ' + printActualType(name) + ')');
  }
  this.type = 'IdentifierExpression';
  this.name = name;
};

var IfStatement = exports.IfStatement = function IfStatement(_ref49) {
  var test = _ref49.test;
  var consequent = _ref49.consequent;
  var alternate = _ref49.alternate;

  _classCallCheck(this, IfStatement);

  if (isNotExpression(test)) {
    throw new TypeError('Field "test" of IfStatement constructor is of incorrect type (expected Expression, got ' + printActualType(test) + ')');
  }
  if (isNotStatement(consequent)) {
    throw new TypeError('Field "consequent" of IfStatement constructor is of incorrect type (expected Statement, got ' + printActualType(consequent) + ')');
  }
  if (alternate === undefined || alternate !== null && isNotStatement(alternate)) {
    throw new TypeError('Field "alternate" of IfStatement constructor is of incorrect type (expected null or Statement, got ' + printActualType(alternate) + ')');
  }
  this.type = 'IfStatement';
  this.test = test;
  this.consequent = consequent;
  this.alternate = alternate;
};

var Import = exports.Import = function Import(_ref50) {
  var defaultBinding = _ref50.defaultBinding;
  var namedImports = _ref50.namedImports;
  var moduleSpecifier = _ref50.moduleSpecifier;

  _classCallCheck(this, Import);

  if (defaultBinding === undefined || defaultBinding !== null && defaultBinding.type !== 'BindingIdentifier') {
    throw new TypeError('Field "defaultBinding" of Import constructor is of incorrect type (expected null or BindingIdentifier, got ' + printActualType(defaultBinding) + ')');
  }
  if (namedImports === undefined || !Array.isArray(namedImports) || namedImports.some(function (f) {
    return f === undefined || f.type !== 'ImportSpecifier';
  })) {
    throw new TypeError('Field "namedImports" of Import constructor is of incorrect type (expected [ImportSpecifier], got ' + printActualType(namedImports) + ')');
  }
  if (moduleSpecifier === undefined || typeof moduleSpecifier !== 'string') {
    throw new TypeError('Field "moduleSpecifier" of Import constructor is of incorrect type (expected string, got ' + printActualType(moduleSpecifier) + ')');
  }
  this.type = 'Import';
  this.defaultBinding = defaultBinding;
  this.namedImports = namedImports;
  this.moduleSpecifier = moduleSpecifier;
};

var ImportNamespace = exports.ImportNamespace = function ImportNamespace(_ref51) {
  var defaultBinding = _ref51.defaultBinding;
  var namespaceBinding = _ref51.namespaceBinding;
  var moduleSpecifier = _ref51.moduleSpecifier;

  _classCallCheck(this, ImportNamespace);

  if (defaultBinding === undefined || defaultBinding !== null && defaultBinding.type !== 'BindingIdentifier') {
    throw new TypeError('Field "defaultBinding" of ImportNamespace constructor is of incorrect type (expected null or BindingIdentifier, got ' + printActualType(defaultBinding) + ')');
  }
  if (namespaceBinding === undefined || namespaceBinding.type !== 'BindingIdentifier') {
    throw new TypeError('Field "namespaceBinding" of ImportNamespace constructor is of incorrect type (expected BindingIdentifier, got ' + printActualType(namespaceBinding) + ')');
  }
  if (moduleSpecifier === undefined || typeof moduleSpecifier !== 'string') {
    throw new TypeError('Field "moduleSpecifier" of ImportNamespace constructor is of incorrect type (expected string, got ' + printActualType(moduleSpecifier) + ')');
  }
  this.type = 'ImportNamespace';
  this.defaultBinding = defaultBinding;
  this.namespaceBinding = namespaceBinding;
  this.moduleSpecifier = moduleSpecifier;
};

var ImportSpecifier = exports.ImportSpecifier = function ImportSpecifier(_ref52) {
  var name = _ref52.name;
  var binding = _ref52.binding;

  _classCallCheck(this, ImportSpecifier);

  if (name === undefined || name !== null && typeof name !== 'string') {
    throw new TypeError('Field "name" of ImportSpecifier constructor is of incorrect type (expected null or string, got ' + printActualType(name) + ')');
  }
  if (binding === undefined || binding.type !== 'BindingIdentifier') {
    throw new TypeError('Field "binding" of ImportSpecifier constructor is of incorrect type (expected BindingIdentifier, got ' + printActualType(binding) + ')');
  }
  this.type = 'ImportSpecifier';
  this.name = name;
  this.binding = binding;
};

var LabeledStatement = exports.LabeledStatement = function LabeledStatement(_ref53) {
  var label = _ref53.label;
  var body = _ref53.body;

  _classCallCheck(this, LabeledStatement);

  if (label === undefined || typeof label !== 'string') {
    throw new TypeError('Field "label" of LabeledStatement constructor is of incorrect type (expected string, got ' + printActualType(label) + ')');
  }
  if (isNotStatement(body)) {
    throw new TypeError('Field "body" of LabeledStatement constructor is of incorrect type (expected Statement, got ' + printActualType(body) + ')');
  }
  this.type = 'LabeledStatement';
  this.label = label;
  this.body = body;
};

var LiteralBooleanExpression = exports.LiteralBooleanExpression = function LiteralBooleanExpression(_ref54) {
  var value = _ref54.value;

  _classCallCheck(this, LiteralBooleanExpression);

  if (value === undefined || typeof value !== 'boolean') {
    throw new TypeError('Field "value" of LiteralBooleanExpression constructor is of incorrect type (expected boolean, got ' + printActualType(value) + ')');
  }
  this.type = 'LiteralBooleanExpression';
  this.value = value;
};

var LiteralInfinityExpression = exports.LiteralInfinityExpression = function LiteralInfinityExpression() {
  _classCallCheck(this, LiteralInfinityExpression);

  this.type = 'LiteralInfinityExpression';
};

var LiteralNullExpression = exports.LiteralNullExpression = function LiteralNullExpression() {
  _classCallCheck(this, LiteralNullExpression);

  this.type = 'LiteralNullExpression';
};

var LiteralNumericExpression = exports.LiteralNumericExpression = function LiteralNumericExpression(_ref55) {
  var value = _ref55.value;

  _classCallCheck(this, LiteralNumericExpression);

  if (value === undefined || typeof value !== 'number') {
    throw new TypeError('Field "value" of LiteralNumericExpression constructor is of incorrect type (expected number, got ' + printActualType(value) + ')');
  }
  this.type = 'LiteralNumericExpression';
  this.value = value;
};

var LiteralRegExpExpression = exports.LiteralRegExpExpression = function LiteralRegExpExpression(_ref56) {
  var pattern = _ref56.pattern;
  var global = _ref56.global;
  var ignoreCase = _ref56.ignoreCase;
  var multiLine = _ref56.multiLine;
  var sticky = _ref56.sticky;
  var unicode = _ref56.unicode;

  _classCallCheck(this, LiteralRegExpExpression);

  if (pattern === undefined || typeof pattern !== 'string') {
    throw new TypeError('Field "pattern" of LiteralRegExpExpression constructor is of incorrect type (expected string, got ' + printActualType(pattern) + ')');
  }
  if (global === undefined || typeof global !== 'boolean') {
    throw new TypeError('Field "global" of LiteralRegExpExpression constructor is of incorrect type (expected boolean, got ' + printActualType(global) + ')');
  }
  if (ignoreCase === undefined || typeof ignoreCase !== 'boolean') {
    throw new TypeError('Field "ignoreCase" of LiteralRegExpExpression constructor is of incorrect type (expected boolean, got ' + printActualType(ignoreCase) + ')');
  }
  if (multiLine === undefined || typeof multiLine !== 'boolean') {
    throw new TypeError('Field "multiLine" of LiteralRegExpExpression constructor is of incorrect type (expected boolean, got ' + printActualType(multiLine) + ')');
  }
  if (sticky === undefined || typeof sticky !== 'boolean') {
    throw new TypeError('Field "sticky" of LiteralRegExpExpression constructor is of incorrect type (expected boolean, got ' + printActualType(sticky) + ')');
  }
  if (unicode === undefined || typeof unicode !== 'boolean') {
    throw new TypeError('Field "unicode" of LiteralRegExpExpression constructor is of incorrect type (expected boolean, got ' + printActualType(unicode) + ')');
  }
  this.type = 'LiteralRegExpExpression';
  this.pattern = pattern;
  this.global = global;
  this.ignoreCase = ignoreCase;
  this.multiLine = multiLine;
  this.sticky = sticky;
  this.unicode = unicode;
};

var LiteralStringExpression = exports.LiteralStringExpression = function LiteralStringExpression(_ref57) {
  var value = _ref57.value;

  _classCallCheck(this, LiteralStringExpression);

  if (value === undefined || typeof value !== 'string') {
    throw new TypeError('Field "value" of LiteralStringExpression constructor is of incorrect type (expected string, got ' + printActualType(value) + ')');
  }
  this.type = 'LiteralStringExpression';
  this.value = value;
};

var Method = exports.Method = function Method(_ref58) {
  var isGenerator = _ref58.isGenerator;
  var name = _ref58.name;
  var params = _ref58.params;
  var body = _ref58.body;

  _classCallCheck(this, Method);

  if (isGenerator === undefined || typeof isGenerator !== 'boolean') {
    throw new TypeError('Field "isGenerator" of Method constructor is of incorrect type (expected boolean, got ' + printActualType(isGenerator) + ')');
  }
  if (name === undefined || name.type !== 'ComputedPropertyName' && name.type !== 'StaticPropertyName') {
    throw new TypeError('Field "name" of Method constructor is of incorrect type (expected one of {ComputedPropertyName, StaticPropertyName}, got ' + printActualType(name) + ')');
  }
  if (params === undefined || params.type !== 'FormalParameters') {
    throw new TypeError('Field "params" of Method constructor is of incorrect type (expected FormalParameters, got ' + printActualType(params) + ')');
  }
  if (body === undefined || body.type !== 'FunctionBody') {
    throw new TypeError('Field "body" of Method constructor is of incorrect type (expected FunctionBody, got ' + printActualType(body) + ')');
  }
  this.type = 'Method';
  this.isGenerator = isGenerator;
  this.name = name;
  this.params = params;
  this.body = body;
};

var Module = exports.Module = function Module(_ref59) {
  var directives = _ref59.directives;
  var items = _ref59.items;

  _classCallCheck(this, Module);

  if (directives === undefined || !Array.isArray(directives) || directives.some(function (f) {
    return f === undefined || f.type !== 'Directive';
  })) {
    throw new TypeError('Field "directives" of Module constructor is of incorrect type (expected [Directive], got ' + printActualType(directives) + ')');
  }
  if (items === undefined || !Array.isArray(items) || items.some(function (f) {
    return f === undefined || f.type !== 'Export' && f.type !== 'ExportAllFrom' && f.type !== 'ExportDefault' && f.type !== 'ExportFrom' && f.type !== 'ExportLocals' && f.type !== 'Import' && f.type !== 'ImportNamespace' && isNotStatement(f);
  })) {
    throw new TypeError('Field "items" of Module constructor is of incorrect type (expected [one of {Export, ExportAllFrom, ExportDefault, ExportFrom, ExportLocals, Import, ImportNamespace, Statement}], got ' + printActualType(items) + ')');
  }
  this.type = 'Module';
  this.directives = directives;
  this.items = items;
};

var NewExpression = exports.NewExpression = function NewExpression(_ref60) {
  var callee = _ref60.callee;
  var _arguments = _ref60.arguments;

  _classCallCheck(this, NewExpression);

  if (isNotExpression(callee)) {
    throw new TypeError('Field "callee" of NewExpression constructor is of incorrect type (expected Expression, got ' + printActualType(callee) + ')');
  }
  if (_arguments === undefined || !Array.isArray(_arguments) || _arguments.some(function (f) {
    return f === undefined || isNotExpression(f) && f.type !== 'SpreadElement';
  })) {
    throw new TypeError('Field "arguments" of NewExpression constructor is of incorrect type (expected [one of {Expression, SpreadElement}], got ' + printActualType(_arguments) + ')');
  }
  this.type = 'NewExpression';
  this.callee = callee;
  this.arguments = _arguments;
};

var NewTargetExpression = exports.NewTargetExpression = function NewTargetExpression() {
  _classCallCheck(this, NewTargetExpression);

  this.type = 'NewTargetExpression';
};

var ObjectAssignmentTarget = exports.ObjectAssignmentTarget = function ObjectAssignmentTarget(_ref61) {
  var properties = _ref61.properties;

  _classCallCheck(this, ObjectAssignmentTarget);

  if (properties === undefined || !Array.isArray(properties) || properties.some(function (f) {
    return f === undefined || f.type !== 'AssignmentTargetPropertyIdentifier' && f.type !== 'AssignmentTargetPropertyProperty';
  })) {
    throw new TypeError('Field "properties" of ObjectAssignmentTarget constructor is of incorrect type (expected [one of {AssignmentTargetPropertyIdentifier, AssignmentTargetPropertyProperty}], got ' + printActualType(properties) + ')');
  }
  this.type = 'ObjectAssignmentTarget';
  this.properties = properties;
};

var ObjectBinding = exports.ObjectBinding = function ObjectBinding(_ref62) {
  var properties = _ref62.properties;

  _classCallCheck(this, ObjectBinding);

  if (properties === undefined || !Array.isArray(properties) || properties.some(function (f) {
    return f === undefined || f.type !== 'BindingPropertyIdentifier' && f.type !== 'BindingPropertyProperty';
  })) {
    throw new TypeError('Field "properties" of ObjectBinding constructor is of incorrect type (expected [one of {BindingPropertyIdentifier, BindingPropertyProperty}], got ' + printActualType(properties) + ')');
  }
  this.type = 'ObjectBinding';
  this.properties = properties;
};

var ObjectExpression = exports.ObjectExpression = function ObjectExpression(_ref63) {
  var properties = _ref63.properties;

  _classCallCheck(this, ObjectExpression);

  if (properties === undefined || !Array.isArray(properties) || properties.some(function (f) {
    return f === undefined || f.type !== 'DataProperty' && f.type !== 'Getter' && f.type !== 'Method' && f.type !== 'Setter' && f.type !== 'ShorthandProperty';
  })) {
    throw new TypeError('Field "properties" of ObjectExpression constructor is of incorrect type (expected [one of {DataProperty, Getter, Method, Setter, ShorthandProperty}], got ' + printActualType(properties) + ')');
  }
  this.type = 'ObjectExpression';
  this.properties = properties;
};

var ReturnStatement = exports.ReturnStatement = function ReturnStatement(_ref64) {
  var expression = _ref64.expression;

  _classCallCheck(this, ReturnStatement);

  if (expression === undefined || expression !== null && isNotExpression(expression)) {
    throw new TypeError('Field "expression" of ReturnStatement constructor is of incorrect type (expected null or Expression, got ' + printActualType(expression) + ')');
  }
  this.type = 'ReturnStatement';
  this.expression = expression;
};

var Script = exports.Script = function Script(_ref65) {
  var directives = _ref65.directives;
  var statements = _ref65.statements;

  _classCallCheck(this, Script);

  if (directives === undefined || !Array.isArray(directives) || directives.some(function (f) {
    return f === undefined || f.type !== 'Directive';
  })) {
    throw new TypeError('Field "directives" of Script constructor is of incorrect type (expected [Directive], got ' + printActualType(directives) + ')');
  }
  if (statements === undefined || !Array.isArray(statements) || statements.some(function (f) {
    return isNotStatement(f);
  })) {
    throw new TypeError('Field "statements" of Script constructor is of incorrect type (expected [Statement], got ' + printActualType(statements) + ')');
  }
  this.type = 'Script';
  this.directives = directives;
  this.statements = statements;
};

var Setter = exports.Setter = function Setter(_ref66) {
  var name = _ref66.name;
  var param = _ref66.param;
  var body = _ref66.body;

  _classCallCheck(this, Setter);

  if (name === undefined || name.type !== 'ComputedPropertyName' && name.type !== 'StaticPropertyName') {
    throw new TypeError('Field "name" of Setter constructor is of incorrect type (expected one of {ComputedPropertyName, StaticPropertyName}, got ' + printActualType(name) + ')');
  }
  if (param === undefined || param.type !== 'BindingWithDefault' && param.type !== 'BindingIdentifier' && param.type !== 'ArrayBinding' && param.type !== 'ObjectBinding') {
    throw new TypeError('Field "param" of Setter constructor is of incorrect type (expected one of {BindingWithDefault, BindingIdentifier, ArrayBinding, ObjectBinding}, got ' + printActualType(param) + ')');
  }
  if (body === undefined || body.type !== 'FunctionBody') {
    throw new TypeError('Field "body" of Setter constructor is of incorrect type (expected FunctionBody, got ' + printActualType(body) + ')');
  }
  this.type = 'Setter';
  this.name = name;
  this.param = param;
  this.body = body;
};

var ShorthandProperty = exports.ShorthandProperty = function ShorthandProperty(_ref67) {
  var name = _ref67.name;

  _classCallCheck(this, ShorthandProperty);

  if (name === undefined || name.type !== 'IdentifierExpression') {
    throw new TypeError('Field "name" of ShorthandProperty constructor is of incorrect type (expected IdentifierExpression, got ' + printActualType(name) + ')');
  }
  this.type = 'ShorthandProperty';
  this.name = name;
};

var SpreadElement = exports.SpreadElement = function SpreadElement(_ref68) {
  var expression = _ref68.expression;

  _classCallCheck(this, SpreadElement);

  if (isNotExpression(expression)) {
    throw new TypeError('Field "expression" of SpreadElement constructor is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');
  }
  this.type = 'SpreadElement';
  this.expression = expression;
};

var StaticMemberAssignmentTarget = exports.StaticMemberAssignmentTarget = function StaticMemberAssignmentTarget(_ref69) {
  var object = _ref69.object;
  var property = _ref69.property;

  _classCallCheck(this, StaticMemberAssignmentTarget);

  if (object === undefined || isNotExpression(object) && object.type !== 'Super') {
    throw new TypeError('Field "object" of StaticMemberAssignmentTarget constructor is of incorrect type (expected one of {Expression, Super}, got ' + printActualType(object) + ')');
  }
  if (property === undefined || typeof property !== 'string') {
    throw new TypeError('Field "property" of StaticMemberAssignmentTarget constructor is of incorrect type (expected string, got ' + printActualType(property) + ')');
  }
  this.type = 'StaticMemberAssignmentTarget';
  this.object = object;
  this.property = property;
};

var StaticMemberExpression = exports.StaticMemberExpression = function StaticMemberExpression(_ref70) {
  var object = _ref70.object;
  var property = _ref70.property;

  _classCallCheck(this, StaticMemberExpression);

  if (object === undefined || isNotExpression(object) && object.type !== 'Super') {
    throw new TypeError('Field "object" of StaticMemberExpression constructor is of incorrect type (expected one of {Expression, Super}, got ' + printActualType(object) + ')');
  }
  if (property === undefined || typeof property !== 'string') {
    throw new TypeError('Field "property" of StaticMemberExpression constructor is of incorrect type (expected string, got ' + printActualType(property) + ')');
  }
  this.type = 'StaticMemberExpression';
  this.object = object;
  this.property = property;
};

var StaticPropertyName = exports.StaticPropertyName = function StaticPropertyName(_ref71) {
  var value = _ref71.value;

  _classCallCheck(this, StaticPropertyName);

  if (value === undefined || typeof value !== 'string') {
    throw new TypeError('Field "value" of StaticPropertyName constructor is of incorrect type (expected string, got ' + printActualType(value) + ')');
  }
  this.type = 'StaticPropertyName';
  this.value = value;
};

var Super = exports.Super = function Super() {
  _classCallCheck(this, Super);

  this.type = 'Super';
};

var SwitchCase = exports.SwitchCase = function SwitchCase(_ref72) {
  var test = _ref72.test;
  var consequent = _ref72.consequent;

  _classCallCheck(this, SwitchCase);

  if (isNotExpression(test)) {
    throw new TypeError('Field "test" of SwitchCase constructor is of incorrect type (expected Expression, got ' + printActualType(test) + ')');
  }
  if (consequent === undefined || !Array.isArray(consequent) || consequent.some(function (f) {
    return isNotStatement(f);
  })) {
    throw new TypeError('Field "consequent" of SwitchCase constructor is of incorrect type (expected [Statement], got ' + printActualType(consequent) + ')');
  }
  this.type = 'SwitchCase';
  this.test = test;
  this.consequent = consequent;
};

var SwitchDefault = exports.SwitchDefault = function SwitchDefault(_ref73) {
  var consequent = _ref73.consequent;

  _classCallCheck(this, SwitchDefault);

  if (consequent === undefined || !Array.isArray(consequent) || consequent.some(function (f) {
    return isNotStatement(f);
  })) {
    throw new TypeError('Field "consequent" of SwitchDefault constructor is of incorrect type (expected [Statement], got ' + printActualType(consequent) + ')');
  }
  this.type = 'SwitchDefault';
  this.consequent = consequent;
};

var SwitchStatement = exports.SwitchStatement = function SwitchStatement(_ref74) {
  var discriminant = _ref74.discriminant;
  var cases = _ref74.cases;

  _classCallCheck(this, SwitchStatement);

  if (isNotExpression(discriminant)) {
    throw new TypeError('Field "discriminant" of SwitchStatement constructor is of incorrect type (expected Expression, got ' + printActualType(discriminant) + ')');
  }
  if (cases === undefined || !Array.isArray(cases) || cases.some(function (f) {
    return f === undefined || f.type !== 'SwitchCase';
  })) {
    throw new TypeError('Field "cases" of SwitchStatement constructor is of incorrect type (expected [SwitchCase], got ' + printActualType(cases) + ')');
  }
  this.type = 'SwitchStatement';
  this.discriminant = discriminant;
  this.cases = cases;
};

var SwitchStatementWithDefault = exports.SwitchStatementWithDefault = function SwitchStatementWithDefault(_ref75) {
  var discriminant = _ref75.discriminant;
  var preDefaultCases = _ref75.preDefaultCases;
  var defaultCase = _ref75.defaultCase;
  var postDefaultCases = _ref75.postDefaultCases;

  _classCallCheck(this, SwitchStatementWithDefault);

  if (isNotExpression(discriminant)) {
    throw new TypeError('Field "discriminant" of SwitchStatementWithDefault constructor is of incorrect type (expected Expression, got ' + printActualType(discriminant) + ')');
  }
  if (preDefaultCases === undefined || !Array.isArray(preDefaultCases) || preDefaultCases.some(function (f) {
    return f === undefined || f.type !== 'SwitchCase';
  })) {
    throw new TypeError('Field "preDefaultCases" of SwitchStatementWithDefault constructor is of incorrect type (expected [SwitchCase], got ' + printActualType(preDefaultCases) + ')');
  }
  if (defaultCase === undefined || defaultCase.type !== 'SwitchDefault') {
    throw new TypeError('Field "defaultCase" of SwitchStatementWithDefault constructor is of incorrect type (expected SwitchDefault, got ' + printActualType(defaultCase) + ')');
  }
  if (postDefaultCases === undefined || !Array.isArray(postDefaultCases) || postDefaultCases.some(function (f) {
    return f === undefined || f.type !== 'SwitchCase';
  })) {
    throw new TypeError('Field "postDefaultCases" of SwitchStatementWithDefault constructor is of incorrect type (expected [SwitchCase], got ' + printActualType(postDefaultCases) + ')');
  }
  this.type = 'SwitchStatementWithDefault';
  this.discriminant = discriminant;
  this.preDefaultCases = preDefaultCases;
  this.defaultCase = defaultCase;
  this.postDefaultCases = postDefaultCases;
};

var TemplateElement = exports.TemplateElement = function TemplateElement(_ref76) {
  var rawValue = _ref76.rawValue;

  _classCallCheck(this, TemplateElement);

  if (rawValue === undefined || typeof rawValue !== 'string') {
    throw new TypeError('Field "rawValue" of TemplateElement constructor is of incorrect type (expected string, got ' + printActualType(rawValue) + ')');
  }
  this.type = 'TemplateElement';
  this.rawValue = rawValue;
};

var TemplateExpression = exports.TemplateExpression = function TemplateExpression(_ref77) {
  var tag = _ref77.tag;
  var elements = _ref77.elements;

  _classCallCheck(this, TemplateExpression);

  if (tag === undefined || tag !== null && isNotExpression(tag)) {
    throw new TypeError('Field "tag" of TemplateExpression constructor is of incorrect type (expected null or Expression, got ' + printActualType(tag) + ')');
  }
  if (elements === undefined || !Array.isArray(elements) || elements.some(function (f) {
    return f === undefined || isNotExpression(f) && f.type !== 'TemplateElement';
  })) {
    throw new TypeError('Field "elements" of TemplateExpression constructor is of incorrect type (expected [one of {Expression, TemplateElement}], got ' + printActualType(elements) + ')');
  }
  this.type = 'TemplateExpression';
  this.tag = tag;
  this.elements = elements;
};

var ThisExpression = exports.ThisExpression = function ThisExpression() {
  _classCallCheck(this, ThisExpression);

  this.type = 'ThisExpression';
};

var ThrowStatement = exports.ThrowStatement = function ThrowStatement(_ref78) {
  var expression = _ref78.expression;

  _classCallCheck(this, ThrowStatement);

  if (isNotExpression(expression)) {
    throw new TypeError('Field "expression" of ThrowStatement constructor is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');
  }
  this.type = 'ThrowStatement';
  this.expression = expression;
};

var TryCatchStatement = exports.TryCatchStatement = function TryCatchStatement(_ref79) {
  var body = _ref79.body;
  var catchClause = _ref79.catchClause;

  _classCallCheck(this, TryCatchStatement);

  if (body === undefined || body.type !== 'Block') {
    throw new TypeError('Field "body" of TryCatchStatement constructor is of incorrect type (expected Block, got ' + printActualType(body) + ')');
  }
  if (catchClause === undefined || catchClause.type !== 'CatchClause') {
    throw new TypeError('Field "catchClause" of TryCatchStatement constructor is of incorrect type (expected CatchClause, got ' + printActualType(catchClause) + ')');
  }
  this.type = 'TryCatchStatement';
  this.body = body;
  this.catchClause = catchClause;
};

var TryFinallyStatement = exports.TryFinallyStatement = function TryFinallyStatement(_ref80) {
  var body = _ref80.body;
  var catchClause = _ref80.catchClause;
  var finalizer = _ref80.finalizer;

  _classCallCheck(this, TryFinallyStatement);

  if (body === undefined || body.type !== 'Block') {
    throw new TypeError('Field "body" of TryFinallyStatement constructor is of incorrect type (expected Block, got ' + printActualType(body) + ')');
  }
  if (catchClause === undefined || catchClause !== null && catchClause.type !== 'CatchClause') {
    throw new TypeError('Field "catchClause" of TryFinallyStatement constructor is of incorrect type (expected null or CatchClause, got ' + printActualType(catchClause) + ')');
  }
  if (finalizer === undefined || finalizer.type !== 'Block') {
    throw new TypeError('Field "finalizer" of TryFinallyStatement constructor is of incorrect type (expected Block, got ' + printActualType(finalizer) + ')');
  }
  this.type = 'TryFinallyStatement';
  this.body = body;
  this.catchClause = catchClause;
  this.finalizer = finalizer;
};

var UnaryExpression = exports.UnaryExpression = function UnaryExpression(_ref81) {
  var operator = _ref81.operator;
  var operand = _ref81.operand;

  _classCallCheck(this, UnaryExpression);

  if (operator === undefined || ["+", "-", "!", "~", "typeof", "void", "delete"].indexOf(operator) === -1) {
    throw new TypeError('Field "operator" of UnaryExpression constructor is of incorrect type (expected one of {"+", "-", "!", "~", "typeof", "void", "delete"}, got ' + printActualType(operator) + ')');
  }
  if (isNotExpression(operand)) {
    throw new TypeError('Field "operand" of UnaryExpression constructor is of incorrect type (expected Expression, got ' + printActualType(operand) + ')');
  }
  this.type = 'UnaryExpression';
  this.operator = operator;
  this.operand = operand;
};

var UpdateExpression = exports.UpdateExpression = function UpdateExpression(_ref82) {
  var isPrefix = _ref82.isPrefix;
  var operator = _ref82.operator;
  var operand = _ref82.operand;

  _classCallCheck(this, UpdateExpression);

  if (isPrefix === undefined || typeof isPrefix !== 'boolean') {
    throw new TypeError('Field "isPrefix" of UpdateExpression constructor is of incorrect type (expected boolean, got ' + printActualType(isPrefix) + ')');
  }
  if (operator === undefined || ["++", "--"].indexOf(operator) === -1) {
    throw new TypeError('Field "operator" of UpdateExpression constructor is of incorrect type (expected one of {"++", "--"}, got ' + printActualType(operator) + ')');
  }
  if (operand === undefined || operand.type !== 'AssignmentTargetIdentifier' && operand.type !== 'ComputedMemberAssignmentTarget' && operand.type !== 'StaticMemberAssignmentTarget') {
    throw new TypeError('Field "operand" of UpdateExpression constructor is of incorrect type (expected one of {AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget}, got ' + printActualType(operand) + ')');
  }
  this.type = 'UpdateExpression';
  this.isPrefix = isPrefix;
  this.operator = operator;
  this.operand = operand;
};

var VariableDeclaration = exports.VariableDeclaration = function VariableDeclaration(_ref83) {
  var kind = _ref83.kind;
  var declarators = _ref83.declarators;

  _classCallCheck(this, VariableDeclaration);

  if (kind === undefined || ["var", "let", "const"].indexOf(kind) === -1) {
    throw new TypeError('Field "kind" of VariableDeclaration constructor is of incorrect type (expected one of {"var", "let", "const"}, got ' + printActualType(kind) + ')');
  }
  if (declarators === undefined || !Array.isArray(declarators) || declarators.some(function (f) {
    return f === undefined || f.type !== 'VariableDeclarator';
  })) {
    throw new TypeError('Field "declarators" of VariableDeclaration constructor is of incorrect type (expected [VariableDeclarator], got ' + printActualType(declarators) + ')');
  }
  this.type = 'VariableDeclaration';
  this.kind = kind;
  this.declarators = declarators;
};

var VariableDeclarationStatement = exports.VariableDeclarationStatement = function VariableDeclarationStatement(_ref84) {
  var declaration = _ref84.declaration;

  _classCallCheck(this, VariableDeclarationStatement);

  if (declaration === undefined || declaration.type !== 'VariableDeclaration') {
    throw new TypeError('Field "declaration" of VariableDeclarationStatement constructor is of incorrect type (expected VariableDeclaration, got ' + printActualType(declaration) + ')');
  }
  this.type = 'VariableDeclarationStatement';
  this.declaration = declaration;
};

var VariableDeclarator = exports.VariableDeclarator = function VariableDeclarator(_ref85) {
  var binding = _ref85.binding;
  var init = _ref85.init;

  _classCallCheck(this, VariableDeclarator);

  if (binding === undefined || binding.type !== 'BindingIdentifier' && binding.type !== 'ArrayBinding' && binding.type !== 'ObjectBinding') {
    throw new TypeError('Field "binding" of VariableDeclarator constructor is of incorrect type (expected one of {BindingIdentifier, ArrayBinding, ObjectBinding}, got ' + printActualType(binding) + ')');
  }
  if (init === undefined || init !== null && isNotExpression(init)) {
    throw new TypeError('Field "init" of VariableDeclarator constructor is of incorrect type (expected null or Expression, got ' + printActualType(init) + ')');
  }
  this.type = 'VariableDeclarator';
  this.binding = binding;
  this.init = init;
};

var WhileStatement = exports.WhileStatement = function WhileStatement(_ref86) {
  var test = _ref86.test;
  var body = _ref86.body;

  _classCallCheck(this, WhileStatement);

  if (isNotExpression(test)) {
    throw new TypeError('Field "test" of WhileStatement constructor is of incorrect type (expected Expression, got ' + printActualType(test) + ')');
  }
  if (isNotStatement(body)) {
    throw new TypeError('Field "body" of WhileStatement constructor is of incorrect type (expected Statement, got ' + printActualType(body) + ')');
  }
  this.type = 'WhileStatement';
  this.test = test;
  this.body = body;
};

var WithStatement = exports.WithStatement = function WithStatement(_ref87) {
  var object = _ref87.object;
  var body = _ref87.body;

  _classCallCheck(this, WithStatement);

  if (isNotExpression(object)) {
    throw new TypeError('Field "object" of WithStatement constructor is of incorrect type (expected Expression, got ' + printActualType(object) + ')');
  }
  if (isNotStatement(body)) {
    throw new TypeError('Field "body" of WithStatement constructor is of incorrect type (expected Statement, got ' + printActualType(body) + ')');
  }
  this.type = 'WithStatement';
  this.object = object;
  this.body = body;
};

var YieldExpression = exports.YieldExpression = function YieldExpression(_ref88) {
  var expression = _ref88.expression;

  _classCallCheck(this, YieldExpression);

  if (expression === undefined || expression !== null && isNotExpression(expression)) {
    throw new TypeError('Field "expression" of YieldExpression constructor is of incorrect type (expected null or Expression, got ' + printActualType(expression) + ')');
  }
  this.type = 'YieldExpression';
  this.expression = expression;
};

var YieldGeneratorExpression = exports.YieldGeneratorExpression = function YieldGeneratorExpression(_ref89) {
  var expression = _ref89.expression;

  _classCallCheck(this, YieldGeneratorExpression);

  if (isNotExpression(expression)) {
    throw new TypeError('Field "expression" of YieldGeneratorExpression constructor is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');
  }
  this.type = 'YieldGeneratorExpression';
  this.expression = expression;
};